<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="keywords" content="rf930creatures1 study3d 0">
<meta name="description" content="rf930creatures1 study3d 0">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>rf930creatures1-study3d-0</title>
<script src="Vector3.js"></script>
<script src="Matrix4x4.js"></script>
<script src="CircleCalculator.js"></script>
<script src="DebugCommands.js"></script>
<script type="text/javascript">
<!--
//キャンバスの大きさ設定とか準備
function start() {
	var in_canvas = document.getElementById("mainCanvas");
	in_canvas.width = 384;
	in_canvas.height = 512;
	this.canvas = in_canvas.getContext("2d");
	
	var scene = new Scene();
	scene.init();
	scene.disp(this.canvas);
}

function Scene() {
}

//描画に必要なデータをセット
Scene.prototype.init = function() {
	//位置データ (ワールド座標)
	this.position = new Vector3(0, 0, 0);
	
	//大きさ
	this.radius = 100; 
	
	//モデルデータ (ローカル座標) //半径*サイン及びコサイン
	this.model = [new Vector3(this.radius * Math.cos(CircleCalculator.toRadian(90)), this.radius * Math.sin(CircleCalculator.toRadian(90)), 0), //下
					new Vector3(this.radius * Math.cos(CircleCalculator.toRadian(-30)), this.radius * Math.sin(CircleCalculator.toRadian(-30)), 0), //右上
					new Vector3(this.radius * Math.cos(CircleCalculator.toRadian(180+30)), this.radius * Math.sin(CircleCalculator.toRadian(180+30)), 0)]; //左上
	
	//行列テスト
	var p = new Vector3(1, 0, 0);
	var m = Matrix4x4_Identity();
	m.rotate(CircleCalculator.toRadian(0), CircleCalculator.toRadian(90), CircleCalculator.toRadian(0));
	var p1 = m.transform(p);
	//期待値：(0, 0, 1)または(0, 0, -1) 結果：(0, 1, 0)
	dp(p1.x + "," + p1.y + "," + p1.z);
}

//描画の実行
Scene.prototype.disp = function(canvas) {
	canvas.save();
	canvas.strokeStyle = "rgb(255, 0, 0)";
	canvas.beginPath();
	
	//行列の作成と適用 ローカル座標からワールド座標に変換
	var wMat = Matrix4x4_Identity();
	wMat.translate(this.position.x, this.position.y, this.position.z);
	var wDrawnModel = [];
	for (var i = 0; i < this.model.length; i++) {
		wDrawnModel[i] = wMat.transform(this.model[i]);
	}
	
	//ワールド座標からカメラ座標(カメラを原点としたときの座標)に変換
	var at = new Vector3(0, 0, 0);			//注視点(カメラの向き)
	var eye = new Vector3(0, 0, -10);		//視点	(カメラの場所)
	var cMat = Matrix4x4_ViewMatrix(at, eye);
	var cDrawnModel = [];
	for (var i = 0; i < this.model.length; i++) {
		cDrawnModel[i] = cMat.transform(wDrawnModel[i]);
	}
	
	//射影変換
	//カメラを原点として、カメラの広さ(視錐台)を定義する。
	//行列を噛ませた結果、中心を0として端が-1or1の数値を得ることができる。
	//(物はワールド座標Z=0、カメラはワールド座標Z=-10に居るが、カメラから見ると物はカメラ座標Z=10にあるので、引数のnearとfarはカメラから見てZ=5～15を見る。)
	var mat3 = Matrix4x4_OrthogonalProjectionMatrix(-220, 220, -220, 220, 5, 15);
	var pDrawnModel = [];
	for (var i = 0; i < this.model.length; i++) {
		pDrawnModel[i] = mat3.transform(cDrawnModel[i]);
	}
	
	//スクリーン変換
	//射影変換した座標を元に、(いわば正規化されているのでそこに)画面の大きさを掛けてスクリーン座標を得る。
	var mat2 = Matrix4x4_ViewportMatrix(384, 512);
	var sDrawnModel = [];
	for (var i = 0; i < this.model.length; i++) {
		sDrawnModel[i] = mat2.transform(pDrawnModel[i]);
	}
	
	//自機は三角形を描く
	var drawnModel = sDrawnModel;
	var len = this.model.length;
	canvas.moveTo(drawnModel[0].x, drawnModel[0].y);
	for (var i = 1; i < len; i++) {
		canvas.lineTo(drawnModel[i].x, drawnModel[i].y);
	}
	
	canvas.closePath();
	canvas.stroke();
	canvas.restore();
}

//中心を引数で取って、十字を描くためのVector3配列を返す
Scene.prototype.crossVertices = function(canvas, center) {
	var width = canvas.canvas.width;
	var height = canvas.canvas.height;
	return [[new Vector3(center.x, 0, 0), new Vector3(center.x, height, 0)], [new Vector3(0, center.y, 0), new Vector3(width, center.y, 0)]];
}

-->
</script>
</head>
<body onLoad="start()">
<canvas id="mainCanvas" style="background-color:black;">
図形を表示するには、canvasタグをサポートしたブラウザが必要です。
</canvas>
</body>
</html>
